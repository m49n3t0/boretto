package bot

import (
    "time"
)

type Task struct {
    ID int64 `db:"id, primarykey, autoincrement" json:"id"`
    Function string `db:"function" json:"function"`
    Name string `db:"name" json:"name"`
    Step string `db:"step" json:"step"`
    Status string `db:"status" json:"status"`
    Retry int `db:"retry" json:"retry"`
    Comment string `db:"comment" json:"comment"`
    CreationDate *time.Time `db:"creation_date" json:"creation_date"`
    TodoDate *time.Time `db:"todo_date" json:"todo_date"`
    LastUpdate *time.Time `db:"last_update" json:"last_update"`
    DoneDate *time.Time `db:"done_date" json:"done_date"`
    Arguments JsonB `db:"arguments" json:"arguments"`
    Buffer JsonB `db:"buffer" json:"buffer"`
}


package credit

import (
	"database/sql"
	"time"
)

type NewTaskParams struct {
	Domain       string
	Function     string
	Arguments    *map[string]interface{}
	CreatedBy    *string
	CustomerCode *string
	ObjectType   *string
	ObjectID     *string
	OrderID      *int64
	EstimateID   *int64
}

func NewTask(params *NewTaskParams) *Task {

	// get now time
	now := time.Now().UTC().Truncate(time.Second)

	// task to create
	pTask := &Task{
		Domain:       params.Domain,
		Function:     params.Function,
		Status:       TaskStatus_TODO,
		Step:         "starting",
		Retry:        8,
		Buffer:       map[string]interface{}{},
		LastReturn:   map[string]interface{}{},
		Trace:        map[string]interface{}{},
		CreationDate: now,
		LastUpdate:   now,
		TodoDate:     now,
	}

	// check nullable value
	if params.Arguments != nil {
		pTask.Arguments = *params.Arguments
	} else {
        pTask.Arguments = map[string]interface{}{}
    }

	// check nullable value
	if params.CreatedBy != nil && *params.CreatedBy != "" {
		pTask.CreatedBy = sql.NullString{String: *params.CreatedBy, Valid: true}
	}

	// check nullable value
	if params.CustomerCode != nil && *params.CustomerCode != "" {
		pTask.CustomerCode = sql.NullString{String: *params.CustomerCode, Valid: true}
	}

	// check nullable value
	if params.ObjectType != nil && *params.ObjectType != "" {
		pTask.ObjectType = sql.NullString{String: *params.ObjectType, Valid: true}
	}

	// check nullable value
	if params.ObjectID != nil && *params.ObjectID != "" {
		pTask.ObjectId = sql.NullString{String: *params.ObjectID, Valid: true}
	}

	// check nullable value
	if params.OrderID != nil && *params.OrderID != 0 {
		pTask.OrderId = sql.NullInt64{Int64: *params.OrderID, Valid: true}
	}

	// check nullable value
	if params.EstimateID != nil && *params.EstimateID != 0 {
		pTask.EstimateId = sql.NullInt64{Int64: *params.EstimateID, Valid: true}
	}

	return pTask
}





// Code generated by pg-schema-loader; DO NOT EDIT.

package credit

import (
	"database/sql"
	"fmt"
	"github.com/go-pg/pg"
	"time"
)

// Task is the go counterpart of table task
type Task struct {
	TableName struct{} `sql:"task"`

	Arguments    map[string]interface{} `sql:"arguments,notnull"`
	Buffer       map[string]interface{} `sql:"buffer,notnull"`
	Comment      sql.NullString         `sql:"comment,notnull"`
	CreatedBy    sql.NullString         `sql:"created_by,notnull"`
	CreationDate time.Time              `sql:"creation_date,notnull"`
	CustomerCode sql.NullString         `sql:"customer_code,notnull"`
	Domain       string                 `sql:"domain,notnull"`
	DoneDate     pg.NullTime            `sql:"done_date,notnull"`
	EstimateId   sql.NullInt64          `sql:"estimate_id,notnull"`
	Function     string                 `sql:"function,notnull"`
	Id           int64                  `sql:"id"`
	LastReturn   map[string]interface{} `sql:"last_return,notnull"`
	LastUpdate   time.Time              `sql:"last_update,notnull"`
	ObjectId     sql.NullString         `sql:"object_id,notnull"`
	ObjectType   sql.NullString         `sql:"object_type,notnull"`
	OrderId      sql.NullInt64          `sql:"order_id,notnull"`
	ParentId     sql.NullInt64          `sql:"parent_id,notnull"`
	Retry        int32                  `sql:"retry,notnull"`
	Status       TaskStatus             `sql:"status,notnull"`
	Step         string                 `sql:"step,notnull"`
	TodoDate     time.Time              `sql:"todo_date,notnull"`
	Trace        map[string]interface{} `sql:"trace,notnull"`
}

const (
	SchemaTask = `"public"`
	TableTask  = `"task"`

	ColTask_Arguments    = `arguments`
	ColTask_Buffer       = `buffer`
	ColTask_Comment      = `comment`
	ColTask_CreatedBy    = `created_by`
	ColTask_CreationDate = `creation_date`
	ColTask_CustomerCode = `customer_code`
	ColTask_Domain       = `domain`
	ColTask_DoneDate     = `done_date`
	ColTask_EstimateId   = `estimate_id`
	ColTask_Function     = `function`
	ColTask_Id           = `id`
	ColTask_LastReturn   = `last_return`
	ColTask_LastUpdate   = `last_update`
	ColTask_ObjectId     = `object_id`
	ColTask_ObjectType   = `object_type`
	ColTask_OrderId      = `order_id`
	ColTask_ParentId     = `parent_id`
	ColTask_Retry        = `retry`
	ColTask_Status       = `status`
	ColTask_Step         = `step`
	ColTask_TodoDate     = `todo_date`
	ColTask_Trace        = `trace`

	QolTask_Arguments    = `"arguments"`
	QolTask_Buffer       = `"buffer"`
	QolTask_Comment      = `"comment"`
	QolTask_CreatedBy    = `"created_by"`
	QolTask_CreationDate = `"creation_date"`
	QolTask_CustomerCode = `"customer_code"`
	QolTask_Domain       = `"domain"`
	QolTask_DoneDate     = `"done_date"`
	QolTask_EstimateId   = `"estimate_id"`
	QolTask_Function     = `"function"`
	QolTask_Id           = `"id"`
	QolTask_LastReturn   = `"last_return"`
	QolTask_LastUpdate   = `"last_update"`
	QolTask_ObjectId     = `"object_id"`
	QolTask_ObjectType   = `"object_type"`
	QolTask_OrderId      = `"order_id"`
	QolTask_ParentId     = `"parent_id"`
	QolTask_Retry        = `"retry"`
	QolTask_Status       = `"status"`
	QolTask_Step         = `"step"`
	QolTask_TodoDate     = `"todo_date"`
	QolTask_Trace        = `"trace"`

	TblTask_Arguments    = `"task"."arguments"`
	TblTask_Buffer       = `"task"."buffer"`
	TblTask_Comment      = `"task"."comment"`
	TblTask_CreatedBy    = `"task"."created_by"`
	TblTask_CreationDate = `"task"."creation_date"`
	TblTask_CustomerCode = `"task"."customer_code"`
	TblTask_Domain       = `"task"."domain"`
	TblTask_DoneDate     = `"task"."done_date"`
	TblTask_EstimateId   = `"task"."estimate_id"`
	TblTask_Function     = `"task"."function"`
	TblTask_Id           = `"task"."id"`
	TblTask_LastReturn   = `"task"."last_return"`
	TblTask_LastUpdate   = `"task"."last_update"`
	TblTask_ObjectId     = `"task"."object_id"`
	TblTask_ObjectType   = `"task"."object_type"`
	TblTask_OrderId      = `"task"."order_id"`
	TblTask_ParentId     = `"task"."parent_id"`
	TblTask_Retry        = `"task"."retry"`
	TblTask_Status       = `"task"."status"`
	TblTask_Step         = `"task"."step"`
	TblTask_TodoDate     = `"task"."todo_date"`
	TblTask_Trace        = `"task"."trace"`
)

func (t Task) check(db *pg.DB) error {
	// Check that column names did not change
	_, err := db.Query(&t, "SELECT "+
		ColTask_Arguments+`,`+
		ColTask_Buffer+`,`+
		ColTask_Comment+`,`+
		ColTask_CreatedBy+`,`+
		ColTask_CreationDate+`,`+
		ColTask_CustomerCode+`,`+
		ColTask_Domain+`,`+
		ColTask_DoneDate+`,`+
		ColTask_EstimateId+`,`+
		ColTask_Function+`,`+
		ColTask_Id+`,`+
		ColTask_LastReturn+`,`+
		ColTask_LastUpdate+`,`+
		ColTask_ObjectId+`,`+
		ColTask_ObjectType+`,`+
		ColTask_OrderId+`,`+
		ColTask_ParentId+`,`+
		ColTask_Retry+`,`+
		ColTask_Status+`,`+
		ColTask_Step+`,`+
		ColTask_TodoDate+`,`+
		ColTask_Trace+
		" FROM "+TableTask+" LIMIT 1")
	if err != nil {
		return fmt.Errorf("Task (SELECT each col): %s", err)
	}

	// Check that all columns are referenced in struct
	_, err = db.Query(&t, "SELECT * FROM "+TableTask+" LIMIT 1")
	if err != nil {
		return fmt.Errorf("Task (SELECT *): %s", err)
	}
	return nil
}




package credit

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

type LegacyRules struct {
	Blacklist []string `json:"blacklist"`
	Whitelist []string `json:"whitelist"`
}

var (
	_ sql.Scanner   = &LegacyRules{}
	_ driver.Valuer = LegacyRules{}
)

// Scan implements the sql.Scanner interface.
func (e *LegacyRules) Scan(value interface{}) (err error) {
	switch v := value.(type) {
	case LegacyRules:
		// Need to deep copy struct
		*e = LegacyRules{
			Blacklist: make([]string, len(v.Blacklist)),
			Whitelist: make([]string, len(v.Whitelist)),
		}
		for idx, str := range v.Blacklist {
			e.Blacklist[idx] = str
		}
		for idx, str := range v.Whitelist {
			e.Whitelist[idx] = str
		}
	case []byte:
		*e = LegacyRules{} // json.Unmarshal does not reset the struct content
		err = json.Unmarshal(v, e)
	case string:
		*e = LegacyRules{} // json.Unmarshal does not reset the struct content
		err = json.Unmarshal([]byte(v), e)
	default:
		return fmt.Errorf("Can't convert %T to credit.LegacyRules", value)
	}
	return
}

var emptySlice = []string{}

// Value implements the driver driver.Valuer interface.
func (e LegacyRules) Value() (driver.Value, error) {
	if e.Blacklist == nil {
		e.Blacklist = emptySlice
	}
	if e.Whitelist == nil {
		e.Whitelist = emptySlice
	}

	jsonBytes, _ := json.Marshal(e)
	return string(jsonBytes), nil
}































// Code generated by pg-schema-loader; DO NOT EDIT.

package credit

import (
	"database/sql/driver"
	"fmt"
)

// CampaignCodeType type is the go counterpart of DB enum campaign_code_type
type CampaignCodeType string

// Scan implements the sql.Scanner interface.
func (e *CampaignCodeType) Scan(value interface{}) error {
	if value == nil {
		*e = CampaignCodeType_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = CampaignCodeType(v)
		return nil
	case []byte:
		*e = CampaignCodeType(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to CampaignCodeType", value)
}

// Value implements the driver driver.Valuer interface.
func (e CampaignCodeType) Value() (driver.Value, error) {
	if e == CampaignCodeType_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	CampaignCodeType_NULL   CampaignCodeType = ""
	CampaignCodeType_RANDOM CampaignCodeType = "RANDOM"
	CampaignCodeType_UNIQUE CampaignCodeType = "UNIQUE"
)

// CampaignStatus type is the go counterpart of DB enum campaign_status
type CampaignStatus string

// Scan implements the sql.Scanner interface.
func (e *CampaignStatus) Scan(value interface{}) error {
	if value == nil {
		*e = CampaignStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = CampaignStatus(v)
		return nil
	case []byte:
		*e = CampaignStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to CampaignStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e CampaignStatus) Value() (driver.Value, error) {
	if e == CampaignStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	CampaignStatus_NULL     CampaignStatus = ""
	CampaignStatus_ACTIVE   CampaignStatus = "ACTIVE"
	CampaignStatus_CREATING CampaignStatus = "CREATING"
	CampaignStatus_DONE     CampaignStatus = "DONE"
	CampaignStatus_EXPIRED  CampaignStatus = "EXPIRED"
	CampaignStatus_UNACTIVE CampaignStatus = "UNACTIVE"
)

// CycleEnum type is the go counterpart of DB enum cycle_enum
type CycleEnum string

// Scan implements the sql.Scanner interface.
func (e *CycleEnum) Scan(value interface{}) error {
	if value == nil {
		*e = CycleEnum_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = CycleEnum(v)
		return nil
	case []byte:
		*e = CycleEnum(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to CycleEnum", value)
}

// Value implements the driver driver.Valuer interface.
func (e CycleEnum) Value() (driver.Value, error) {
	if e == CycleEnum_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	CycleEnum_NULL  CycleEnum = ""
	CycleEnum_DAY   CycleEnum = "DAY"
	CycleEnum_MONTH CycleEnum = "MONTH"
)

// OperationEnum type is the go counterpart of DB enum operation_enum
type OperationEnum string

// Scan implements the sql.Scanner interface.
func (e *OperationEnum) Scan(value interface{}) error {
	if value == nil {
		*e = OperationEnum_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = OperationEnum(v)
		return nil
	case []byte:
		*e = OperationEnum(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to OperationEnum", value)
}

// Value implements the driver driver.Valuer interface.
func (e OperationEnum) Value() (driver.Value, error) {
	if e == OperationEnum_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	OperationEnum_NULL         OperationEnum = ""
	OperationEnum_BONUS        OperationEnum = "BONUS"
	OperationEnum_CANCEL       OperationEnum = "CANCEL"
	OperationEnum_GIFT         OperationEnum = "GIFT"
	OperationEnum_ORDER        OperationEnum = "ORDER"
	OperationEnum_REFUND_POINT OperationEnum = "REFUND_POINT"
	OperationEnum_UNPAID       OperationEnum = "UNPAID"
	OperationEnum_USE          OperationEnum = "USE"
	OperationEnum_VOUCHER      OperationEnum = "VOUCHER"
)

// ProgramModuleIterationStatus type is the go counterpart of DB enum program_module_iteration_status
type ProgramModuleIterationStatus string

// Scan implements the sql.Scanner interface.
func (e *ProgramModuleIterationStatus) Scan(value interface{}) error {
	if value == nil {
		*e = ProgramModuleIterationStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = ProgramModuleIterationStatus(v)
		return nil
	case []byte:
		*e = ProgramModuleIterationStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to ProgramModuleIterationStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e ProgramModuleIterationStatus) Value() (driver.Value, error) {
	if e == ProgramModuleIterationStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	ProgramModuleIterationStatus_NULL     ProgramModuleIterationStatus = ""
	ProgramModuleIterationStatus_CREATED  ProgramModuleIterationStatus = "CREATED"
	ProgramModuleIterationStatus_CREATING ProgramModuleIterationStatus = "CREATING"
)

// ProgramModuleParticipantIterationStatus type is the go counterpart of DB enum program_module_participant_iteration_status
type ProgramModuleParticipantIterationStatus string

// Scan implements the sql.Scanner interface.
func (e *ProgramModuleParticipantIterationStatus) Scan(value interface{}) error {
	if value == nil {
		*e = ProgramModuleParticipantIterationStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = ProgramModuleParticipantIterationStatus(v)
		return nil
	case []byte:
		*e = ProgramModuleParticipantIterationStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to ProgramModuleParticipantIterationStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e ProgramModuleParticipantIterationStatus) Value() (driver.Value, error) {
	if e == ProgramModuleParticipantIterationStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	ProgramModuleParticipantIterationStatus_NULL     ProgramModuleParticipantIterationStatus = ""
	ProgramModuleParticipantIterationStatus_CREATED  ProgramModuleParticipantIterationStatus = "CREATED"
	ProgramModuleParticipantIterationStatus_CREATING ProgramModuleParticipantIterationStatus = "CREATING"
)

// ProgramModuleParticipantStatus type is the go counterpart of DB enum program_module_participant_status
type ProgramModuleParticipantStatus string

// Scan implements the sql.Scanner interface.
func (e *ProgramModuleParticipantStatus) Scan(value interface{}) error {
	if value == nil {
		*e = ProgramModuleParticipantStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = ProgramModuleParticipantStatus(v)
		return nil
	case []byte:
		*e = ProgramModuleParticipantStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to ProgramModuleParticipantStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e ProgramModuleParticipantStatus) Value() (driver.Value, error) {
	if e == ProgramModuleParticipantStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	ProgramModuleParticipantStatus_NULL     ProgramModuleParticipantStatus = ""
	ProgramModuleParticipantStatus_CREATED  ProgramModuleParticipantStatus = "CREATED"
	ProgramModuleParticipantStatus_CREATING ProgramModuleParticipantStatus = "CREATING"
	ProgramModuleParticipantStatus_DELETED  ProgramModuleParticipantStatus = "DELETED"
	ProgramModuleParticipantStatus_DELETING ProgramModuleParticipantStatus = "DELETING"
)

// ProgramModuleStatus type is the go counterpart of DB enum program_module_status
type ProgramModuleStatus string

// Scan implements the sql.Scanner interface.
func (e *ProgramModuleStatus) Scan(value interface{}) error {
	if value == nil {
		*e = ProgramModuleStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = ProgramModuleStatus(v)
		return nil
	case []byte:
		*e = ProgramModuleStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to ProgramModuleStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e ProgramModuleStatus) Value() (driver.Value, error) {
	if e == ProgramModuleStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	ProgramModuleStatus_NULL     ProgramModuleStatus = ""
	ProgramModuleStatus_ACTIVE   ProgramModuleStatus = "ACTIVE"
	ProgramModuleStatus_CLOSED   ProgramModuleStatus = "CLOSED"
	ProgramModuleStatus_CREATING ProgramModuleStatus = "CREATING"
	ProgramModuleStatus_EXPIRED  ProgramModuleStatus = "EXPIRED"
	ProgramModuleStatus_UNACTIVE ProgramModuleStatus = "UNACTIVE"
)

// ProgramStatus type is the go counterpart of DB enum program_status
type ProgramStatus string

// Scan implements the sql.Scanner interface.
func (e *ProgramStatus) Scan(value interface{}) error {
	if value == nil {
		*e = ProgramStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = ProgramStatus(v)
		return nil
	case []byte:
		*e = ProgramStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to ProgramStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e ProgramStatus) Value() (driver.Value, error) {
	if e == ProgramStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	ProgramStatus_NULL     ProgramStatus = ""
	ProgramStatus_ACTIVE   ProgramStatus = "ACTIVE"
	ProgramStatus_CLOSED   ProgramStatus = "CLOSED"
	ProgramStatus_CREATING ProgramStatus = "CREATING"
	ProgramStatus_EXPIRED  ProgramStatus = "EXPIRED"
	ProgramStatus_UNACTIVE ProgramStatus = "UNACTIVE"
)

// TaskStatus type is the go counterpart of DB enum task_status
type TaskStatus string

// Scan implements the sql.Scanner interface.
func (e *TaskStatus) Scan(value interface{}) error {
	if value == nil {
		*e = TaskStatus_NULL
		return nil
	}

	switch v := value.(type) {
	case string:
		*e = TaskStatus(v)
		return nil
	case []byte:
		*e = TaskStatus(v)
		return nil
	}
	return fmt.Errorf("Can't convert %T to TaskStatus", value)
}

// Value implements the driver driver.Valuer interface.
func (e TaskStatus) Value() (driver.Value, error) {
	if e == TaskStatus_NULL {
		return nil, nil
	}
	return string(e), nil
}

const (
	TaskStatus_NULL      TaskStatus = ""
	TaskStatus_CANCELLED TaskStatus = "CANCELLED"
	TaskStatus_DOING     TaskStatus = "DOING"
	TaskStatus_DONE      TaskStatus = "DONE"
	TaskStatus_ERROR     TaskStatus = "ERROR"
	TaskStatus_INIT      TaskStatus = "INIT"
	TaskStatus_PROBLEM   TaskStatus = "PROBLEM"
	TaskStatus_TODO      TaskStatus = "TODO"
)
































package task

import (
	"github.com/go-openapi/runtime/middleware"
	"stash.ovh.net/enginebilling/api_credit/models"
	"stash.ovh.net/enginebilling/api_credit/restapi/common"

	log "github.com/sirupsen/logrus"
)

/* DoGetTasks GET /tasks

Return a list of tasks

*/
func DoGetTasks(params GetTasksParams) middleware.Responder {

	// get the pagination parmeters
	perPage, page, mErr := common.GetPagination(params.PerPage, params.Page)
	if mErr != nil {
		return NewGetTasksDefault(int(mErr.Code)).WithPayload(mErr)
	}

	// do database request
	pTasks, count, mErr := DbGetTasksByParams(
		params.HTTPRequest.Context(),
		&GetTasksStruct{
			CustomerCode: params.CustomerCode,
			OrderId:      params.OrderID,
			EstimateId:   params.EstimateID,
			PerPage:      perPage,
			Page:         page,
		})

	if mErr != nil {
		return NewGetTasksDefault(int(mErr.Code)).WithPayload(mErr)
	}

	// response
	var mResponse models.TasksResponse

	// build credit types data
	if len(pTasks) > 0 {
		mResponse.Tasks = make([]*models.Task, len(pTasks))
		for idx, pTask := range pTasks {
			mResponse.Tasks[idx] = GetApiModelFromDbCreditModelTask(pTask)
		}

		// meta data only if elements
		mResponse.Meta = &models.MetaData{Total: count}

		// if pagination activated
		if params.PerPage != nil {
			mResponse.Meta.This = *params.PerPage
		}
	} else {
		mResponse.Tasks = []*models.Task{}
	}

	log.Println("OK")

	return NewGetTasksOK().WithPayload(&mResponse)
}

/* DoGetTask GET /tasks/{task_id}

Return a task

*/
func DoGetTask(params GetTaskParams) middleware.Responder {

	// do database request
	pTask, mErr := DbGetTaskByParams(
		params.HTTPRequest.Context(),
		&GetTaskStruct{
			TaskID: params.TaskID,
		})

	if mErr != nil {
		return NewGetTaskDefault(int(mErr.Code)).WithPayload(mErr)
	}

	// build response
	mResponse := models.TaskResponse{
		Task: GetApiModelFromDbCreditModelTask(pTask),
	}

	log.Println("OK")

	return NewGetTaskOK().WithPayload(&mResponse)
}











































package task

import (
	"context"
	"github.com/go-openapi/strfmt"
	"github.com/go-pg/pg"
	"net/http"
	"stash.ovh.net/enginebilling/api_credit/models"
	"stash.ovh.net/enginebilling/api_credit/restapi/common"
	"stash.ovh.net/enginebilling/tools/go/databases/models/credit"

	creditdb "stash.ovh.net/enginebilling/tools/go/databases/go-pg/credit"
)

////////////////////////////////////////////////////////////////////////

// Transform the API models.Task from the DB model credit.Task
func GetApiModelFromDbCreditModelTask(pTask *credit.Task) *models.Task {

	status := string(pTask.Status)
	creationDate := strfmt.DateTime(pTask.CreationDate.UTC())
	lastUpdate := strfmt.DateTime(pTask.LastUpdate.UTC())
	todoDate := strfmt.DateTime(pTask.TodoDate.UTC())

	mTask := models.Task{
		ID:           &pTask.Id,
		CreationDate: &creationDate,
		LastUpdate:   &lastUpdate,
		TodoDate:     &todoDate,
		Function:     &pTask.Function,
		Status:       &status,
	}

	// translate nul date time
	if pTask.DoneDate.IsZero() != true {
		doneDate := strfmt.DateTime(pTask.DoneDate.UTC())
		mTask.DoneDate = &doneDate
	}

	// translate null string
	if pTask.CustomerCode.Valid {
		mTask.CustomerCode = common.StringToPtr( pTask.CustomerCode.String )
	}

	return &mTask
}

// Struct to params the get of a task list
type GetTasksStruct struct {
	Function        *string
	CustomerCode    *string
	OrderId         *int64
	EstimateId      *int64
	PerPage         *int64
	Page            *int64
}

// Database get tasks list function
func DbGetTasksByParams(ctx context.Context, params *GetTasksStruct) ([]*credit.Task, int64, *models.Error) {

	// get db handler
	rd, err := creditdb.GetRO()
	if err != nil {
		return nil, 0, common.VaultdbError(err)
	}

	// object to fetch
	var tasks []*credit.Task

	// create query
	query := rd.WithContext(ctx).
		Model(&tasks).
		OrderExpr("id ASC")

	// check optional pagination params
	query, pErr := common.Paginator(query, params.PerPage, params.Page)
	if pErr != nil {
		return nil, 0, pErr
	}

	// optional filter
	if params.Function != nil && *params.Function != "" {
		query = query.Where(credit.TblTask_Function+" = ?", *params.Function)
	}

	// optional filter
	if params.CustomerCode != nil && *params.CustomerCode != "" {
		query = query.Where(credit.TblTask_CustomerCode+" = ?", *params.CustomerCode)
	}

	// optional filter
	if params.OrderId != nil && *params.OrderId != 0 {
		query = query.Where(credit.TblTask_OrderId+" = ?", *params.OrderId)
	}

	// optional filter
	if params.EstimateId != nil && *params.EstimateId != 0 {
		query = query.Where(credit.TblTask_EstimateId+" = ?", *params.EstimateId)
	}

	// execute query with parameters
	count, err := query.SelectAndCount()

	if err != nil {
		return nil, 0, common.RequestError(err)
	}

	return tasks, int64(count), nil
}

// Struct to params the get one task
type GetTaskStruct struct {
	TaskID          int64
	CustomerCode    *string
}

// Database get one task function
func DbGetTaskByParams(ctx context.Context, params *GetTaskStruct) (*credit.Task, *models.Error) {

	// get db handler
	rd, err := creditdb.GetRO()
	if err != nil {
		return nil, common.VaultdbError(err)
	}

	// object to fetch
	var task credit.Task

	// do the query
	query := rd.WithContext(ctx).
		Model(&task).
		Where(credit.TblTask_Id+" = ?", params.TaskID)

	// optional filter
	if params.CustomerCode != nil && *params.CustomerCode != "" {
		query = query.Where(credit.TblTask_CustomerCode+" = ?", *params.CustomerCode)
	}

	// do the query
	err = query.First()

	if err != nil {
		if err == pg.ErrNoRows {
			return nil, models.NewError(http.StatusNotFound, "Task not found")
		}
		return nil, common.RequestError(err)
	}

	return &task, nil
}







package common

import (
	"github.com/go-pg/pg/orm"
	log "github.com/sirupsen/logrus"
	"net/http"
	"stash.ovh.net/enginebilling/api_credit/models"
)

////////////////////////////////////////////////////////////////////////

func StringToPtr(val string) *string {
	return &val
}

func BoolToPtr(val bool) *bool {
	return &val
}

func VaultdbError(err error) *models.Error {
	log.Println(err)
	return models.NewError(http.StatusInternalServerError, "DB access failed")
}

func RequestError(err error) *models.Error {
	log.Println(err)
	return models.NewError(http.StatusInternalServerError, "DB request failed")
}

func GetPagination(perPage *int64, page *int64) (*int64, *int64, *models.Error) {
	if perPage == nil {
		var val int64
		val = 25

		perPage = &val
	}

	if page != nil && *page == 0 {
		var val int64
		val = 0

		page = &val
	}

	return perPage, page, nil
}

func Paginator(query *orm.Query, perPage *int64, page *int64) (*orm.Query, *models.Error) {

	// check optional pagination params
	pager := &orm.Pager{Limit: 25, MaxLimit: 2500}

	// no filter when the two parameters not defined
	if perPage == nil && page == nil {
		return query, nil
	}

	if perPage != nil && *perPage != 0 {
		pager.Limit = int(*perPage)
	}

	if page != nil && *page > 0 {
		pager.SetPage(int(*page))
	}

	// retrieve query with pagination
	query, err := pager.Paginate(query)
	if err != nil {
		return nil, RequestError(err)
	}

	return query, nil
}
:x

